### 🌟**招银网路科技面试（一）**

1. ==和equals的区别

```text
- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型 == 比较的是**值**，引用数据类型 == 比较的是**内存地址**)。
- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况:
    情况 1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过 “==” 比较这两个对象。
    情况 2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等;若它们的内容相等，则返回 true (即，认为这两个对象相等)。
- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的**内存地址**，而 String 的 equals 方法比较的是对象的**值**。
```

2. 一个类的两个对象怎么进行比较

```text
- 使用 == ，但是不是很好。
- 重写 equals 方法，用 对象1.equals(对象2) 判断。
- 设计一个抽象类 CompareObject，其中定义方法 compareTo(用x和y这两个成员表示坐标，并实现compareTo()方法{return y;} 
```

3. 有没有可能两个对象 equals 为 true 但是 hashcode 不同

```text
- 如果该对象重写了 equals 方法，那么可能会出现 equals 相同，但 hashcode 不同的情况，但假如没有重写 equals 方法，那么它默认继承是 Object 的 equals 方法，根据源码可知，此时 equals 相同，hashcode 一定相同。
- 当你把对象加入 HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加入的位置， 同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方 法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加入操作成 功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。
```

4. 如果出现了上述这种情况，有可能发生什么情况？

```text
- 重写 equals 时必须重写 hashCode 方法。hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode() ，则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)
```

5. 用过多线程吗，怎么实现的多线程？

```text
- Thread ——> 继承 Thread ——> 重写run方法 ——> 创建线程对象，通过start()启动线程
- Runnable接口 ——> 实现Runnable接口 ——> 重写run方法 ——> 创建线程类，不能直接调用start方法，需要创建Thread类。 ——> 使用new Thread(Runnable) 构造函数 ——> 调用thread.start()方法启动线程
```

6. 线程池的线程具体在什么时候创建一个线程或者销毁一个线程？

```text
- 线程池中的线程不是被动销毁的，而是线程自己本身发现无任务可做之后，整个生命周期自然而然的结束。
- 由 getTask 方法的阻塞状态来决定销毁（非核心线程）还是阻塞（核心线程）
- 线程池在任务提交的时候创建一个线程
```

7. 手动实现一个死锁的情况

```text
- 线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000); 让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相 等待的状态，这也就产生了死锁。
- 互斥条件:该资源任意一个时刻只由一个线程占用。
- 请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
```

8. 有ABC三个线程，怎么编程让B在C前面执行，A在B前面执行

```text
- 使用 join 。 join 作用是：如果某个线程调用 join 方法，优先执行完该线程，才能够执行其它线程。
- 使用单线程池。
- 使用 CountDownLatch 。可以把 CountDownLatch 看作是一个计数器，如果调用其 await() 方法，那么此对象就会一直处于等待状态，直到 countDown 为 0 ，才会继续执行下去。
```

9. 问一下数据结构，你了解哪些二叉树的种类和他们的具体使用场景

```text
- 满二叉树
- 完全二叉树，在堆中使用。
- 二叉搜索树，前序遍历后堆结果是有序的。
- 平衡二叉搜索树，在二叉树的基础上平衡因子为 1 ，C++ 中 map ， set 通过这个实现。
- 红黑二叉树，红黑树是一种自平衡二叉树，就是在每次插入新的数据的时候，红黑树会进行变色和旋转来使生成的树不会出现偏的情况。 Java 中 TreeMap 就是通过这个实现的。
```

10. AVL树了解吗

```text
- AVL树 是**带有平衡条件的二叉查找树**,一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡,左右子树树高不超过 1 ,和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过1).不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道**AVL树适合用于插入删除次数比较少，但查找多的情况。**
```

11. 红黑树了解吗

```text
- 一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,可以是 red 或 black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保没有一条路径会比其它路径长出两倍.它是一种弱平衡二叉树(由于是弱平衡,可以推出,相同的节点情况下,AVL树 的高度低于红黑树),相对于要求严格的AVL树来说,它的旋转次数变少，**所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。**
```

12. 红黑树的具体应用场景，举个例子

```text
- java 中 TreeMap 的实现。与 HashMap 相比，TreeMap 是一个能比较元素大小的 Map 集合，会对传入的 key 进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。
- 广泛用于 C++ 的STL中，map 和 set 都是用红黑树实现的。
```

13. 为什么用红黑树不一直用链表

```text
- 当长度低于 6 时会由红黑树转成链表,TreeNodes 占用空间是普通 Nodes 的两倍,所以只有当 bin 包含足够多的节点时才会转成 TreeNodes。
- 使用链表
```

14. 为什么用红黑树不用普通二叉树

```text
-  TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了 **解决二叉查找树的缺陷**，因为二叉查找树在某些情况下会退化成一个线性结构。
```

15. 普通二叉树深度太深会导致什么？

```text
- 和链表无异，导致查找效率低下。
```

16. B树和B+树知道吗？区别是什么？

```text
- B树
    1.关键字集合分布在整颗树中；
    2.任何一个关键字出现且只出现在一个结点中；
    3.搜索有可能在非叶子结点结束；
    4.其搜索性能等价于在关键字全集内做一次二分查找；
- B+树
    1.b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
    2.b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
    3.对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历
```

17. B树和B+树的应用场景说一下

```text
- B树 多用于做文件系统的索引。
- B+树是在B树的基础上进行改造的，他的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。
- B+树多用于数据库中的索引。
```

18. 给字段加索引最好怎么加？

```text
- 直接创建完整索引，这样可能比较占用空间；
- 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
- 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
- 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。
```

19. 什么情况下使用复合索引更好？

```text
- 复合索引能形成索引覆盖,提高 where 语句的查询效率
- 如果一个表中的数据在查询时有多个字段总是同时出现则这些字段就可以作为复合索引,形成索引覆盖可以提高查询的效率
```

20. 什么情况下会导致索引失效？

```text
- 当全表扫描速度比索引快的时候，不会使用索引！
- Like查询条件以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效；
- or语句左右字段没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效；
- 联合索引没有遵循最左前缀原则；
- 在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引；
- 索引字段是表达式或者函数的一部分，即索引不是独立的列。
```

21. 为什么使用模糊匹配会失效，你能给我解释一下底层原理吗？

```text
- 最左前缀原则
- 索引的排列顺序是根据比较字符串的首字母排序的，如果首字母相同，就根据比较第二个字母进行排序，以此类推。
- 我们在进行模糊查询的时候，如果把 % 放在了前面，最左的  n 个字母便是模糊不定的，无法根据索引的有序性准确的定位到某一个索引，只能进行全表扫描，找出符合条件的数据。
```

22. 网络协议有了解吗，为什么Tcp是三次握手四次挥手不是四四或者三三？

```text
- 三次握手即可确认连接已正常建立，不需要第四次来造成资源浪费；
- 四次挥手才能保证服务器和客户端均没有话再说了，也确定了对面没有话再说了
```

23. 平时做项目用http还是https?

```text
- HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。HTTP 协议是以明文方式发送信息的。
- HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。
    非对称加密，对称加密；中间人攻击；数字签名
```

24. SSL套接字的过程？

```text
- 对称加密：常见的DES算法，其包含一个密钥，加密和解密过程使用的是同一个密钥。
- 非对称加密：常见的RSA算法，存在一组public key 和 private key  即一组公钥和私钥
    采取公钥加密的数据通过私钥解密
    采取私钥加密的数据通过公钥解密。
- 因此一个安全的SSL套接字传输过程为：
    1.首先发送数字证书，获取到可信的public key
    2.通过public key发送对称秘钥，接收方用私钥解密。
    3.通信双方使用仅仅对方可知的对称秘钥进行加密传输
```

25. SSL在历史上有一次心脏流血漏洞，这个漏洞怎么出现的？

```text
- 工作原理：SSL标准包含一个心跳选项，允许SSL连接一端的电脑发出一条简短的信息，确认另一端的电脑仍然在线，并获取反馈。
- 研究人员发现，可以通过巧妙的手段发出恶意心跳信息，欺骗另一端的电脑泄露机密信息。受影响的电脑可能会因此而被骗，并发送服务器内存中的信息。
```

26. 设计模式用过吗？

```text
- 单例模式。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式
    第一种为懒汉式:只是在调用 getinstance 时生成对象，不 getinstance 不生成。但是会有线程安全问题，一般加锁，但是效率稍微低一些。
    第二种为饿汉式 :即直接以静态属性在类的内部，作为唯一单例
- 工厂模式
    创造对象的工厂，想要创建对象的时候直接从工厂里拿而 不是自己new，将创建者和调用者分离。
- 适配器模式
    适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起
工作。举个例子，比如你想给苹果手机充电，但是你只有Type-c的充电线，这时你可以设计一个转接头，转接头就是一种适配器。
- 外观模式
    举例子:如果是自己泡茶的话，需要准备茶叶，茶具，和开水。而去茶馆的话就只需要说老子要一碗冰红茶就OK了，服务员会帮
你准备好一切。
- 代理模式。提供一种代理以控制一个对象对其他对象的访问。可分为静态代理和动态代理。
    静态代理:自己实现代理类和被代理类接口，每一个类都有不同的代理
    动态代理:可以通过反射的方式代理多个类。
- 策略模式
        针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响 到客户端的情况下发生变化。
- 观察者模式
```

27. 那我们来聊聊单例模式，单例模式有几种实现方式？（这里有一个地方说错了，说成饿汉是编译时期生成了）

```text
- 单例模式。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式
    第一种为懒汉式:只是在调用 getinstance 时生成对象，不 getinstance 不生成。但是会有线程安全问题，一般加锁，但是效率稍微低一些。
    第二种为饿汉式 :即直接以静态属性在类的内部，作为唯一单例
```

28. 你再想想，是编译时期吗？我问下你，你写的代码如何运行，这个过程你说一下（对不起！！！！）

```text
- 
```

29. 为什么双重校验，一次校验不行吗（这题我会！）

```text
- 第一次校验：
    也就是第一个if（singleton==null），这个是**为了代码提高代码执行效率**，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用 getInstance 方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。
- 第二次校验：
    也就是第二个if（singleton==null），**这个校验是防止二次创建实例**，假如有一种情况，当 singleton 还未被创建时，线程 t1 调用 getInstance 方法，由于第一次判断 singleton==null ，此时线程 t1 准备继续执行，但是由于资源被线程 t2 抢占了，此时 t2 也调用 getInstance 方法，同样的，由于 singleton 并没有实例化，t2 同样可以通过第一个 if ，然后继续往下执行，同步代码块，第二个 if 也通过，然后 t2 线程创建了一个实例 singleton。此时 t2 线程完成任务，资源又回到 t1 线程，t1 此时也进入同步代码块，如果没有这个第二个 if，那么，t1 就也会创建一个 singleton 实例，那么，就会出现创建多个实例的情况，但是加上第二个 if，就可以完全避免这个多线程导致多次创建实例的问题。
```

30. 那怎么用一次校验实现线程安全？（我忘了orz开始胡言乱语，没有自信的问静态内部类可以吗）

```text
- 在getInstance()方法上加上了synchronized锁，就变成了线程安全的版本。但是这种直接在方法上加锁的方式其实对并发的效率影响是很大的
```

31. 静态内部类效率也不太好，你能有什么优化方法吗（对不起！！！我真的没用过我不会！！！）

```text
- 
```

32. 再来问问网络安全吧，Sql注入…（慌张打断，说我不了解网络安全，没有学过这方面）

```text
- SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。
    1.寻找到SQL注入的位置
    2.判断服务器类型和后台数据库类型
    3.针对不同的服务器和数据库特点进行SQL注入攻击
```

33. 没关系，那接着聊，刚才说的hashmap，hashmap怎么解决hash冲突

```text
- 链地址法
```

34. 除了链地址法还有其他的解决hash冲突的方法吗（开放定址和再哈希）

```text
- 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
- 再哈希法
- 建立一个公共溢出区
```

35. 如果hashmap溢出了怎么办（建立公共溢出区？）

```text
- 建立公共溢出区 / 扩容
```

36. 公共溢出区也满了怎么办？（啊…？这我真的盲区了，我说hashmap也会扩容吧…？）

```text
- 
```

37. 说一下hashmap扩容的过程？

```text
- 当数组table存储的键值对元素个数（size）大于数组容量的0.75（threshold=capacity*0.75）的时候，我们需要对数组进行扩容，当需要扩容时，令 capacity 为原来的两倍。
- 在重新计算 键值对哈希值%新的数组长度 的时候，先计算 键值对哈希值&旧的数组长度 ，若计算结果为0，那么 键值对哈希值%新的数组长度 与 键值对哈希值%旧的数组长度 是相同的；若不为0，键值对哈希值%新的数组长度 = 键值对哈希值%旧的数组长度+旧数组的长度。
```

38. 你对jvm有了解吗？说一下jvm的内存分区？

```text
- JVM的内存划分中，有部分区域是线程私有的（每个线程有一个），有部分区域是属于整个虚拟机共享的；有些区域会抛出OOM异常，有些则不会。

- 第一，是程序计数器（Program Counter Register)，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。
- 第二，Java虚拟机栈(Java Virtal Machine Stack)，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。
    该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。
- 第三，本地方法栈（Native Method Stack）与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。
- 第四，堆（Heap）,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。
- 第五，方法区（Method Area)。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。
    根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。
- 第六，运行时常量池（Run-Time Constant Pool)，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。
- 第七，直接内存（Direct Memory），直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。
```

39. 堆里面怎么分区的？（这题真不会，只说知道为了方便垃圾回收所以分了新生代区和老年代区，其他的真不知道）

```text
- - 第四，堆（Heap）,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。
```

40. 没关系，那你知道一个对象怎么从新生代变成老年代吗？（懵逼，对不起，不知道，只简单的知道两个区的定义）

```text
- 根据对象年龄
    JVM会给对象增加一个年龄(age)的计数器，对象每“熬过”一次GC，年龄就要+1，待对象到达设置的阈值(默认为15岁)就会被移移动到老年代
- 动态年龄判断
    根据对象年龄有另外一个策略也会让对象进入老年代，不用等待15次GC之后进入老年代，他的大致规则就是，假如当前放对象的Survivor，一批对象的总大小大于这块Survivor内存的50%，那么大于这批对象年龄的对象，就可以直接进入老年代了。
- 大对象直接进入老年代
```

41. 手撕代码，一个数组nums，一个数组values，每次只能从nums头或尾取，假设第i次取的值是x，价值=x*values[i-1]，求怎么取得总价值最大？（十分钟，心态崩了，真没撕出来，第一次思路错了，就说用动态规划做）

```java
class Solution {
    /**
     * 招行笔试算法题：有两个长度均为n，的数组a，b，从a数组头或尾取出一个数，
     * 假设第i次取的值为ax,那么第i次的价值为b[i - 1]*ax，
     * 价值总和为前i-1次价值之和加上第i次的价值，求第n次取数最大价值总和
     * 知识点：双指针加动态规划
     * @param nums int整型一维数组 
     * @param values int整型一维数组 
     * @return int整型
     */
    public int getMaxValue(int[] nums, int[] values) {
        int dp[] = new int[nums.length + 1];
        int left = 0;
        int right = nums.length - 1;
        dp[0] = 0;
        int i = 1;
        for (int value : values) {
            if (left > right) {
                return dp[nums.length];
            }
            if (nums[left] > nums[right]) {
                dp[i] = dp[i - 1] + nums[left] * value;
                left++;
            } else {
                dp[i] = dp[i - 1] + nums[right] * value;
                right--;
            }
            i++;
        }
        return dp[nums.length];
    }

    public static void main(String[] args) {
        int[] a = new int[]{1, 2, 3, 4};
        int[] b = new int[]{7, 6, 5, 4};
        int maxValue = new Solution().getMaxValue(a, b);
        System.out.println(maxValue);
    }

}
```

42. 为什么动态规划可以做（我不知道，我已经崩溃了）

```text
- 
```

43. 那你说一下这题动态规划做的话时间复杂度是多少（我不知道，我已经不行了，真的快疯了）

```text
- 
```

44. 你有什么问题问我？（评价一下我的面试表现，回答说建议不要背书，多看看底层，哭了，不背书前面这40题我一题也不会啊）

```text
- 
```

### **招银网路科技面试（二）**

1. java基本数据类型

2. java对象生命周期

3. mysql和redis区别

4. 线程生命周期

5. 多线程好处

6. 线程池作用

7. 数据库mysql的隔离级别

8. 怎么实现多线程安全

9. jvm的类加载机制和垃圾回收原理

10.b+树和红黑树区别

11.二叉树的遍历方法 写按层遍历二叉树

12.flink和spark的区别

13.单例模式和适配器模式

### **招银网路科技面试（三）**

1. string类可以继承吗

```text
不可以，首先 String 是个 final 类，所以该类是不能被继承的，实现了 Comparable（具有比较性）、Serializable 和 CharSequence 接口。
```

2. final关键字

3. 普通类和抽象类的区别

4. mysql:

5. mysql的数据类型

6. 浮点型有decimal

7. char和vchar

8. mysql有没有string

9. 线程同步

10.hashmap和hashtable区别，在扩容上呢

11.写两个栈实现队列

### **招银网路科技面试（四）**

1. tcp三次握手过程

2. http和https区别

3. https怎么加密

4. 如何预防中间人攻击

5. 聊项目

6. error和ecxeption说一下

```text
Error 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。 此类错误一般表示代码运行时 JVM 出现问题，通常有 Virtual MachineError (虚拟机运行错误)、NoClassDefFoundError(类定义错误)等; Exception 是 非严重的异常，对于 Exception，程序本身可以捕获并且可以处理的这些异常。 (RuntimeException 可以捕获但是没有必要)。
```

7. 如何把exception提取出来

### **招银网路科技面试（五）**

1. 一个类，如果重写了Equals(),不重写HashCode()，会有什么问题

2. 说说HashMap底层，get()和put()复杂度是多少，什么情况下不是O(1)

3. 有没有写过内部类，内部类能否引用外部类的private成员

4. 多线程中怎么同步

```text
- 同步方法：即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
- 同步代码块:即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
- 使用特殊域变量(Volatile)实现线程同步
- 使用重入锁实现线程同步
- 使用局部变量实现线程同步
```

5. 怎么新建一个线程

6. 线程池

7. 阻塞队列

8. 说说AOP和IOC

```text

```

9. Spring用到了哪些设计模式

```text
- 工厂模式：Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象
- 单例模式：Bean默认为单例模式
- 策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略
- 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术
- 模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate, JmsTemplate, JpaTemplate
- 适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式，Spring MVC中也是用到了适配器模式适配Controller
- 观察者模式：Spring事件驱动模型就是观察者模式的一个经典应用。
- 桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库
```

10. bean的作用域

11. Redis有哪些对象

12. Mysql建索引有哪些准则

```text
- 最左前缀匹配原则
- =和in可以乱序
- 尽量选择区分度高的列作为索引
- 索引列不能参与计算，保持列“干净”
- 尽量的扩展索引，不要新建索引。
```

### **招银网路科技面试（六）**

1. 自我介绍

2. 手撕堆排序

3. 再手撕个快排吧

4. 函数传递值，传递引用，传递地址有什么区别

5. 讲一下进程和线程的区别吧

6. 讲一下线程间的通信

7. 讲一下你的项目

8. 你觉得你项目的难点是什么

9. 讲一下线程和进程，多线程和多进程

10. 多线程和多进程分别怎么加锁，要控制哪些变量，你在纸上写一下

11. 多线程的任务队列怎么实现？要怎么加锁，在纸上写一下吧

12. 那现在题目变难一点，如果不同任务，有不同的延迟时间，你这个队列怎么存取任务，要考虑哪些因素？在纸上写一下吧

13. 现在有一个40万条的合法URL集合，你设计一个过滤器，过滤掉非法的URL访问……如果大量访问并发，你怎么处理

14. 红黑树（因为提示我上面的应该用红黑树）和平衡二叉树，哪个更好……你是从哪些方面考虑的

### 🌟**招银网路科技面试（七）**

1. 说一下线程有几种状态

```text

```

2. 说一下线程池，如果这时候线程数满了，还有别的线程进来你该怎样做？（情景题）答了个拒绝策略和阻塞队列也不知道对不对

```text

```

3. 说一下并发读写的问题，问了一下synchronized和lock类

```text

```

4. 说一下java内存模型，主存和工作内存 （不小心扯了jvm的模型，还好大牛给我拉回来了，尴尬了几秒钟）

```text

```

5. 说一下volatile优点和缺点

```text

```

（防止指令重排啊还有不能原子性那些）

你刚刚说到cas，详说一下CAS？你知道怎么实现吗？

6. 说一下atomic原子类

```text

```

7. 多线程玩的不错，说一下hashmap和concurrent hashmap的区别， put的时候bucket不够大怎么扩容啊？

```text

```

（提了一下jdk1.8之后的的hashmap区别和concurrent hashmap 的区别，分段锁和[链表](file:///jump/super-jump/word%3fword=%E9%93%BE%E8%A1%A8)
转红黑那些，还有扩容机制）

8. 说一下这个trasational的注解原理是什么

```text

```

（不会….尴尬，查了一下是aop动态代理 spring用的多是吧，说一下springboot自动配置的原理

9. 说一下put和post的区别和应用场景

```text

```

10. 说一下你实习的内容，这个数据库怎么优化，有什么用

```text

```

11. 说一下用jmeter干过什么，怎么对它进行压测啊？（只会生成性能图，哈哈哈哈我是废物）

```text

```

12. 用过mysql是吧，说一下索引的结构，和底层实现，有什么优点啊

```text

```

13. 说一下回表？，为什么不用[红黑树](file:///jump/super-jump/word%3fword=%E7%BA%A2%E9%BB%91%E6%A0%91)呢？脏读是什么？幻读是什么？

```text

```

14. 读写并发用过乐观锁？（没有，但知道是版本号机制）

```text

```

15. Spring cloud用过是吧，说一下open feign怎么用的，为什么要用open feign 啊有什么优点啊

```text

```

（说了一下咋用，依赖于注册中心）

消息中间件用过吧？说一下？

16. dp迷宫问题，需要强制用dp做

```text

```

暴力深度dfs搜超时那种

17. 项目亮点？

18. 技术选型

19. 问了点基础

20. 问了数据库优化

21. 项目的一个点拿出来拷问了一下

（项目自己做的所以难度因人而异

22. 说一下Spring aop吧？对，动态代理说一下？

```text

```

23. 你会设计模式？建造者模式说来听听？

（可能单例都知道双重检测了哈哈哈考个别的，还好学过

老生常问：现在觉得有什么不足和有什么能优化的

24. redis有多少种数据结构常用？用来做过什么？

25. 平时怎么学习的啊？小伙子以后有什么规划啊？

### 🌟**招银网路科技面试（八）**

1. hashmap和hashtable的区别

```text
- HashTable 使用 synchronized 来进行同步，因此其可以使用在多线程环境下，而 HashMap 只能使用在单线程环境;
- HashMap 可以插入 key 为 null 的 Entry 键值对，而 HashTable 的键 不允许为 null，HashTable 的值也不可以为 null;
- HashTable 的默认桶数是 11，而 HashMap 是 16，HashTable 扩 容的时候，容量乘 2 加 1，而 HashMap 只是乘 2。
```

2. 线程有哪些实现方式？start和run的区别是什么？

```text
主线程执行 start()方法，会开启一个新的线程，如果新的线程获取到 CPU 资源，则会执行这个线程的 run()方法的内容;而如果在主线程中运行 run()方 法，并不会开启一个新的线程，而仅仅是运行某个线程定义的 run()方法而已。
```

3. 线程之间的通信有哪些？

```text
- 全局变量  进程中的线程间内存共享，这是比较常用的通信方式和交互方式。
           注：定义全局变量时最好使用volatile来定义，以防编译器对此变量进行优化。   
- Message消息机制 PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。
- CEvent对象     CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步。
```

4. 线程池的类型？以及spring和jdk自带线程池的比较

```text

```

5. redis的淘汰策略

```text
- noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(大部分的写入指令,但 DEL 和几个例外) 
- allkeys-lru: 尝试回收最少使用的键(LRU),使得新添加的数据有空间存放。 
- volatile-lru: 尝试回收最少使用的键(LRU),但仅限于在过期集合的键,使得新添加的数据有空间存放。 
- allkeys-random: 回收随机的键使得新添加的数据有空间存放。 
- volatile-random: 回收随机的键使得新添加的数据有空间存放,但仅限于在过期集合的键。 
- volatile-ttl: 回收在过期集合的键,并且优先回收存活时间(TTL)较短的键,使得新添加的数据有空间存放。
```

6. redis的分布式锁的实现？为什么不用开源组件呢？有哪些开源的组件可用以及原理?

```text

```

7. mysql的引擎有哪些？innodb与myisam的区别？

```text
MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的 值为地址读取相应的数据记录。这被称为“非聚簇索引”。
InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其 表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记 录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚 簇索引(或聚集索引)”。而其余的索引都作为􏰄助索引，􏰄助索引的data域存储相应记录主 键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所 在的节点即可取出数据;在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索 引。 因此，在设计表的时候，不建议使用过⻓的字段作为主键，也不建议使用非单调的字段 作为主键，这样会造成主索引频繁分裂。
```

8. 建立索引需要注意哪些？怎么知道是否命中了索引

```text

```

9. mq如果消费异常了要怎么处理？打日志和补偿

```text

```

10. 服务节点有多少？每个节点的数据连接数是多少？会把mysql的连接打爆吗？

```text

```

11. 分布式事务有了解么？

```text

```

12. 分表是按什么分的？用户id。为什么有临时表，用来做什么的？用于解决多用户查询时分页的问题

```text

```

13. 冷热隔离是什么？为什么要冷热隔离？

```text
但是，由于只有当前年表数据会不断变化（热数据），历史年表数据不会修改（冷数据），因此正真有数据变化操作的数据量相对整个库来看并不大。那么，我们将数据库设计为历史年表数据放到Read only的文件组上，把当前年表数据放到Read write的文件组上，备份系统仅仅需要备份Primary和当前年表所在的文件组即可（当然首次还是需要对数据库做一次性完整备份的）。这样既可以大大节约备份对I/O能力的消耗，又实现了冷热数据的隔离备份操作，还达到了分散了文件的I/O压力，最终达到数据库设计和备份系统优化的目的
```

14. 如果一个接口慢了？用skywalking、arthas。如果没有开源工具呢？用jmap、jstack(jdk自带总可以用吧:))。不看日志的么？。。。会看的（啥日志能看出哪里慢？）

```text

```

15. 数据库语句怎么看它慢在哪里？explain

```text
一、MySQL数据库有几个配置选项可以帮助我们及时捕获低效SQL语句
    - slow_query_log    这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。
    - long_query_time   当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。
    - slow_query_log_file   记录日志的文件名。
    - log_queries_not_using_indexes 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。
二、检测mysql中sql语句的效率的方法
    - 通过查询日志

```

### 🌟**招银网路科技面试（九）**

1. java你怎么看待继承这个问题的

```text
- 创建一个新的类可以继承一个父类(基类)，新的类可以使用父类公 共的成员变量与方法，从而实现代码复用
- 封装：将一个事物的属性与行为封装成为类，用类来描述这个事物，类的属性与方法分别表示这个事物的属性与行为。
- 
```

2. 接口和抽象类的区别

```text
- 抽象类：抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类最大的区别是，抽象类不能被实例化。一个类如果继承抽象类，这个类要么重写抽象类的所有抽象方法，要么这个类本身也是抽象类。
- 接口：接口用 interface 关键字修饰，一个类继承接口，要么这个类重写接口的所有抽象方法，要么这个类是抽象类。
- 一个类可以实现多个接口，但是只能继承一个抽象类；
- 接口不能有构造方法，而抽象类可以有构造方法；
- 抽象类中可以有普通方法（有方法体），在 JDK1.8 之前接口只能有抽象方法；在 JDK1.8，接口可以有默认方法（public default）和静态方法（public static）；在 JDK1.9，接口可以有私有方法（private）。
- 抽象类可以有普通的变量，而接口只能有常量。
```

4. 多态你是怎么解释的

```text
多态:多态是指一个对象变量可以指示多种类型的对象(指示多个类类型)， 多态通过继承(多个子类继承同一个父类)或者接口(多个实现类实现同一个接 口)。多态的特点是“父类的引用指向子类的对象”或者是“父接口的引用指向 子实现类的对象”。
```

3. 重写跟重载有什么区别

```text
- 重载:重载存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。重载与返回值、修饰符、抛出的异 常无关，这些都可以修改;
- 重写:存在于继承体系中，指子类实现了一个与父类同名的方法，这个方法 的参数列表必须与父类相同。另外，子类方法的访问权限必须大于等于父类方法; 子类方法的返回类型必须是父类方法返回类型或为其子类型;子类方法抛出的异 常类型必须是父类抛出异常类型或为其子类型。
```

4. equal的重写方法有了解吗

```text

```

5. ==跟equal的区别有哪些

```text
- 对于引用数据类型:在 Object 类中，equals 方法与==都用于比较 2 个变量的内存地址是否相同，即 2 个变量是否引用同一个对象;
- 而 Object 的 String、 Math 等子类重写了 equals 方法，equals 用于比较 2 个对象的是否等价(即先 比较 2 个对象类型是否相同，相同的话再比较对象中的字段的值是否相同)，而 == 依然用于比较 2 个变量的地址是否相同。
```

6. java的基本集合知道那些

```text
一.List集合：（有序，元素可以重复）
    1.ArrayList集合：
        - 底层数据结构是数组，查找快，增删慢。
        - 线程不安全，效率高
    2.Vector集合：
        - 底层数据结构是数组，查询快，增删慢
        - 线程安全，效率低
    3.LinkedList集合：
        - 底层数据结构是链表，查询慢，增删快
        - 线程不安全，效率高

二、Set集合（元素不可重复，元素唯一）
    1.Hashset集合：
        - 底层数据结构是哈希表，哈希表依赖两个方法 hascode() 和 equals()方法
        - 两个方法的执行顺序：
            首先判断hascode()值是否相同
            是：继续执行equals()方法，看其返回值
                是true：说明元素重复，不添加
                是false：就直接添加元素
            否：就直接添加到集合
    2.Treeset集合：
        - 底层数据结构是二叉树
```

7. map，set的区别

```text
- map 是键值对，set 是值的集合，当然键和值可以是任何的值；
- map 可以通过 get 方法获取值，而 set 不能因为它只有值；
- 都能通过迭代器进行 for...of 遍历；
- set 的值是唯一的，可以做数组去重，map 由于没有格式限制，可以做数据存储
- map 和 set 都是 stl 中的关联容器，map 以键值对的形式存储，key = value 组成 pair ，是一组映射关系。set 只有值，可以认为只有一个数据，并且 set 中元素不可以重复且自动排序。
```

8. map里面是如何遍历的（纯粹自己挖坑，不是很理解这个问题）

```text
- 方法一 在for-each循环中使用entries来遍历
- 方法二 在for-each循环中遍历keys或values。
- 方法三 使用Iterator遍历
- 方法四 通过键找值遍历（效率低）
```

9. 那些map是安全的，如何使这个map安全

```text
HashTable:和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。
- 现在可以使用 ConcurrentHashMap 来支持线程安全， 并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
```

10. 多线程相关

```text

```

11. synchronized关键字了解那些，说说你的理解

```text
- synchronized 是 Java 的一个关键字，一般用于修饰方法或者代码块，它 解决的是多个线程并发访问共享资源的同步问题，synchronized 关键字可以保 证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
- volatile 也是 Java 的一个关键字，可用于修饰变量，也可以用于处理多线 程的并发问题，保证被修饰变量的可见性与有序性。
- volatile 关键字只能用于变量而synchronized 关键字可以修饰方法以及代 码块。
- volatile 可以保证变量被多线程并发访问时的可见性与有序性，而 synchronized 可以保证同步代码块/方法被多线程并发访问时的原子性，可见 性，有序性。
- volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。Synchronized 之前是一种重量级锁，现在 synchronized 对锁进行了优化，引入了轻量级锁和偏向锁，性能有了显著的提升，因此 synchronized 在实际开发中用的比较多。
```

12. 翻转链表

```java
class Solution {
    //方法一：迭代（双指针） + 之后的每一个结点都通过头插法插入到该链表中
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;
        while (cur != null) {
            ListNode tmp = cur.next; // 暂存后继节点 cur.next
            cur.next = pre;          // 修改 next 引用指向
            pre = cur;               // pre 暂存 cur
            cur = tmp;               // cur 访问下一节点
        }
        return pre;
    }
}
```

```java
class Solution {
    //方法二：递归 调转每一个指针的下一个结点的方向
    public ListNode reverseList(ListNode head) {
        return recur(head, null);    // 调用递归并返回
    }

    private ListNode recur(ListNode cur, ListNode pre) {
        if (cur == null) return pre; // 终止条件
        ListNode res = recur(cur.next, cur);  // 递归后继节点
        cur.next = pre;              // 修改节点引用指向
        return res;                  // 返回反转链表的头节点
    }
}
```

### 🌟**招银网路科技面试（十）**

1. 自我介绍

```text
面试官您好!我叫林桂洪,目前就读于广东工业大学计算机学院计算机科学与技术专业。 在大学期间我利用课外时间学习了 Java 相关知识, 掌握 Java 常见的集合容器、Java 多线程编程、Java 虚拟机及垃圾回收机制等 Java 基础知识,能够使用Java 常见的 SSM 框架。掌握计算机网络与操作系统等课程的的相关知识,对MySQL 以及 Redis 的使用及原理也有一定的了解。项目方面,我自己做了一个小型的 B2C 电商项目,我完成了该项目后台部分的开发,并将这个项目发布到云服务器上。 平平时空闲的时候我喜欢浏览别人的技术博客来学习新的知识。 在大学期间我多次获得奖学金, 学习成绩在全年级20%以内。 
生活中我是一个比较比较乐观的人,平时喜欢下棋和打篮球。我一直都非常想加入贵公司, 我觉得贵公司的文化和技术氛围都非常吸引我, 期待能与你共事!
```

2. StringBuilder和StringBuffer区别

```text
- String 类中使用 final 关键字修饰 byte 数组来保存字符串，String 的长度是不可变的。 StringBuffer 的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer ，如果最后需要 String ，那么使用 StringBuffer 的 toString() 方法即可。
- StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，但是没有用 final 关键字修饰，**所以这两种对象都是可变的**。
- StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的。
- StringBuilder 并没有对方法进行加同步锁，所以是**非线程安全**的。
- 相同情况下使用 StringBuilder 相比使用 StringBuffer **性能更好**，但却要冒多线程不安全的⻛险。
```

3. HashMap底层实现

```text
- JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置(这里的 n 指的是数组的⻓度)，**如果当前位置存在元素的话**，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过**拉链法**解决冲突。
- JDK1.8 之后在解决哈希冲突时有了较大的变化，**当链表⻓度大于阈值**(默认为 8)(将链表转换成红黑树前会判断，如果当前数组的⻓度小于 64 ，那么会选择先**进行数组扩容**，而不是转换为红黑树)时，**将链表转化为红黑树**，以减少搜索时间。
```

4. Java创建线程方式

```text
- 继承Thread类创建线程类
- 通过Runnable接口创建线程类
- 通过Callable和Future创建线程
```

5. 线程池的参数

```text
- corePoolsize 线程池核心线程大小
    线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毀，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。
- maximumPoolSize 线程池最大线程数量
    一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。
- keepAliveTime 空闲线程存活时间
    一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毀，这里的指定时间由keepAlive Time来设定
- unit 空闲线程存活时间单位。keepAlive Time的计量单位
- workoueue 工作队列
    新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jak中提供了四种工作队列：
        1.DArravBlockinaQueue
            基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolsize，则会执行拒绝策略。
        2.PLinkedBlockingQuene
            基于链表的无界阻塞队列（其实最大容量为interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolsize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxpoolsize其实是不起作用的。
        3.SynchronousQuene
            一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolsize.执行拒绝策略
        4.PrioritvBlockingQueue
            具有优先级的无界阻塞队列_，优先级通过参数Comparator实现。
- threadFactorv 线程工厂
    创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等
- handler 拒绝第略
```

6. 序列化与反序列化

```text
- Java 对象的序列化，即将 Java 对象转换为一组二进制字节(字节数组)， 用于保存到磁盘或通过网络传输到其他网络结点。需要注意的是，只会序列化对 象的成员变量，而静态变量是不会序列化的，方法也不会序列化，同时，被 transient 修饰的属性也不会被序列化。当然，我们也可以通过反序列化将二进 制字节重新转换为 Java 对象。
- Java 对象的序列化，使得对象可以脱离 JVM 而存在，否则当 JVM 的生命 周期结束的时候，Java 对象也会被销毁。这样 Java 对象就可以持久化到硬盘或 者发送给其他网络结点。
- 所有可在网络上传输的对象都必须是可序列化的，所有需要保存到磁盘的 java 对象都必须是可序列化的。
```

7. 遇到过的异常有哪些

```text
 
```

8. 遇到过内存泄漏和内存溢出的情况？如何排查内存溢出
   [内存泄漏和内存溢出有啥区别](https://www.zhihu.com/question/40560123)

```text
内存溢出
- Java堆溢出
- 虚拟机栈和本地方法栈溢出
- 方法区和运行时常量池溢出
- 本机直接内存溢出
内存泄漏    简单说就是应该被垃圾回收的对象没有被垃圾回收。
- 静态集合类引起内存泄漏
- 变量不合理的作用域
- 引用了外部类的非静态内部类
- Hash 值发生改变
```

9. redis有哪些数据类型

```text
 String、List、Set、Sorted Set、hashes
```

10. 项目：点赞功能如何实现 / 缓存穿透与缓存雪崩 / redis的Zset底层实现
11. 项目：如何发现SQL问题？SQL是如何优化的？
12. 算法：二叉树层数遍历（IDE貌似不支持向上转型，静态类型List必须改为ArrayList）

```text
 
```

**技术二面 3.24 35min**

1. 自我介绍
2. 项目难点介绍
3. 本地缓存与redis缓存区别

```text

```

4. 介绍下redis及应用

```text
Redis 本质上是一个 Key-Value 类型的内存数据库,很像 memcached,整个数据库统统加载在内存当中进行操作,定期通过异步操作把数据库数据 flush 到硬盘上进行保存。

```

5. 本地缓存与redis缓存一致性

```text

```

6. redis与MySQL数据一致性

```text
就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。
- 第一种方案：采用延时双删策略
    在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
    先删除缓存；
    再写数据库；
    休眠500毫秒；
    再次删除缓存。

- 第二种方案：异步更新缓存(基于订阅binlog的同步机制)
    读Redis：热数据基本都在Redis
    写MySQL:增删改都是操作MySQL
    更新Redis数据：MySQ的数据操作binlog，来更新到Redis
```

7. 说下前端负载均衡和后端负载均衡

```text
一般成熟的做法是将静态资源，图片、js啊之类的放到CDN上，可以改善加载体验和应对流量的能力；后端接口则一般放到负载均衡后面，根据你的架构和并发量，可能部署多个实例。
```

8. 近似有序的数组的最优复杂度是多少

```text
几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。 冒泡排序O（n），插入排序O（n）
```

9. 浏览器输入URL的执行流程

```text
- 进行域名解析（获取IP地址）
- 发起TCP的3次握手
- 建立TCP连接后发起http请求
- 服务器响应http请求
- 浏览器解析html代码，并请求html代码中的资源(如js,css,图片等)
- 断开TCP连接
- 浏览器对页面进行渲染呈现给用户
```

10. ARP协议的作用？属于哪一层？

```text
ARP地址解析协议，即ARP（Address ResoluTIon Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。属于网络层。
```

11. 说下AOP？用过AOP？Spring AOP的注解有哪些？

```text
AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容（Spring核心之一），是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

- 切面(Aspect): 指关注点模块化,这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中,切面可以使用通用类基于模式的方式(schema-based approach)或者在普通类中以 @Aspect 注解(@AspectJ 注解方式)来实现。
- 连接点(Join point): 在程序执行过程中某个特定的点,例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中,一个连接点总是代表一个方法的执行。
- 通知(Advice): 在切面的某个特定的连接点上执行的动作。通知有多种类型,包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架,包括Spring在内,都是以拦截器做通知模型的,并维护着一个以连接点为中心的拦截器链。
- 切点(Pointcut): 匹配连接点的断言。通知和切点表达式相关联,并在满足这个切点的连接点上运行(例如,当执行某个特定名称的方法时)。切点表达式如何和连接点匹配是AOP的核心:Spring默认使用AspectJ 切点语义。
- 引入(Introduction): 声明额外的方法或者某个类型的字段。Spring允许引入新的接口(以及一个对应的实现)到任何被通知的对象上。例如,可以使用引入来使bean实现 IsModified 接口, 以便简化缓存机制(在AspectJ社区,引入也被称为内部类型声明(inter))。
- 目标对象(Target object): 被一个或者多个切面所通知的对象。也被称作被通知(advised)对象。既然Spring AOP是通过运行时代理实现的,那么这个对象永远是一个被代理(proxied)的对象。
- AOP代理(AOP proxy):AOP框架创建的对象,用来实现切面契约(aspect contract)(包括通知方法执行等功能)。在Spring中,AOP代理可以是JDK动态代理或CGLIB代理。
- 织入(Weaving): 把切面连接到其它的应用程序类型或者对象上,并创建一个被被通知的对象的过程。这个过程可以在编译时(例如使用AspectJ编译器)、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样,是在运行时完成织入的。 

```

12. AOP的切面与切点的区别？

```text
- 切面(Aspect): 指关注点模块化,这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中,切面可以使用通用类基于模式的方式(schema-based approach)或者在普通类中以 @Aspect 注解(@AspectJ 注解方式)来实现。
- 切点(Pointcut): 匹配连接点的断言。通知和切点表达式相关联,并在满足这个切点的连接点上运行(例如,当执行某个特定名称的方法时)。切点表达式如何和连接点匹配是AOP的核心:Spring默认使用AspectJ 切点语义。
```

13. 聚簇索引与非聚簇索引的区别？

```text
- 聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据
- 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点保存了指向数据对应行的指针。
```

14. 主键索引与唯一索引的区别？

```text
- 主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是 PRIMARY 而不是 UNIQUE。
```

15. 算法：二叉树前序遍历非递归（先写成递归形式，一激动又写成非递归层序遍历...）
16. 反问 / 应届生培养体系 / 业务线

### 🌟**招银网路科技面试（十一）**

1. 介绍List和Map的数据结构（ArrayList、LinkedList、HashMap的底层数据结构）

```text
一.List集合：（有序，元素可以重复）
    1.ArrayList集合：
        - 底层数据结构是数组，查找快，增删慢。
        - 线程不安全，效率高
    2.Vector集合：
        - 底层数据结构是数组，查询快，增删慢
        - 线程安全，效率低
    3.LinkedList集合：
        - 底层数据结构是链表，查询慢，增删快
        - 线程不安全，效率高
二.Map集合：
    1.TreeMap：基于红黑树实现（有序）。
    2.HashMap：基于哈希表实现（无序）。
    3.HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。
    4.现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
    5.LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
```

2. ArrayList和LinkedList的应用场景

```text
ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况
```

3. HashMap在多线程情况下会有哪些问题，解释一下造成死循环的原因

```text
- HashMap在多线程put后可能导致get无限循环 
- 多线程put的时候可能导致元素丢失
    考虑在多线程下put操作时，执行 addEntry(hash, key, value, i)，如果有产生哈希碰撞，导致两个线程得到同样的 bucketIndex 去存储，就可能会出现覆盖丢失的情况：
如何使用线程安全的
- 使用 Hashtable 类，Hashtable 是线程安全的；
- 使用并发包下的 java.util.concurrent.ConcurrentHashMap，ConcurrentHashMap 实现了更高级的线程安全；
- 或者使用 synchronized Map() 同步方法包装 HashMap object，得到线程安全的 Map，并在此 Map 上进行操作。
```

4. String和StringBuffer的区别

```text
- String 类中使用 final 关键字修饰 byte 数组来保存字符串，String 的长度是不可变的。 StringBuffer 的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer ，如果最后需要 String ，那么使用 StringBuffer 的 toString() 方法即可。
- StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，但是没有用 final 关键字修饰，**所以这两种对象都是可变的**。
- StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的。
- StringBuilder 并没有对方法进行加同步锁，所以是**非线程安全**的。
- 相同情况下使用 StringBuilder 相比使用 StringBuffer **性能更好**，但却要冒多线程不安全的⻛险。
```

5. synchronized与ReentrantLock的区别

```text
- 底层实现上来说，synchronized 是JVM层面的锁，是Java关键字，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法，ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的API层面的锁。
- 是否可手动释放：synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过 lock() 和 unlock() 方法配合 try/finally 语句块来完成，使用释放更加灵活。
- 是否可中断：synchronized 是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock 则可以中断，可通过 trylock(long timeout,TimeUnit unit) 设置超时方法或者将 lockInterruptibly() 放到代码块中，调用interrupt方法进行中断。
- 是否公平锁：synchronized 为非公平锁 ReentrantLock 则即可以选公平锁也可以选非公平锁，通过构造方法 new ReentrantLock 时传入 boolean 值进行选择，为空默认 false 非公平锁，true 为公平锁。
- 锁的对象：synchronzied 锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock 锁的是线程，根据进入的线程和 int 类型的 state 标识锁的获得/争抢。
```

6. 造成死锁的原因，出现死锁怎么解决

```text
- 互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。
- 请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。  ——> ⼀次性申请所有的资源。
- 不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。      ——> 占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。       ——> 靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。
```

7. volatile的作用，如何保证可见性

```text
- 保证修饰变量的可见性和有序性
- 被 volatile 关键字修饰的变量，线程每次要对其进行操作的时候，都会直接从主内存进行读取。这样如果有线程对这个变量进行修改，由于线程都是从主内存读取该变量，因此其他线程可以直接读取到修改后的变量的值，这就保证了这个变量的可见性。
- volatile 关键字通过添加内存屏障的方式来禁止指令重排，这样就保证了多线程操作变量的有序性，使得多线程对变量的并发操作不会出错。
```

8. 说说 synchronized 关键字和 volatile 关键字的区别

```text
synchronized 是 Java 的一个关键字，一般用于修饰方法或者代码块，它 解决的是多个线程并发访问共享资源的同步问题，synchronized 关键字可以保 证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
- volatile 也是 Java 的一个关键字，可用于修饰变量，也可以用于处理多线 程的并发问题，保证被修饰变量的可见性与有序性。
- volatile 关键字只能用于变量而synchronized 关键字可以修饰方法以及代 码块。
- volatile 可以保证变量被多线程并发访问时的可见性与有序性，而 synchronized 可以保证同步代码块/方法被多线程并发访问时的原子性，可见性，有序性。
- volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。Synchronized 之前是一种重量级锁，现在 synchronized 对锁进行了优化，引入了轻量级锁和偏向锁，性能有了显著的提升，因此 synchronized 在实际开发中用的比较多。
```

9. TCP与UDP的区别

```text
- TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。
- UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接.
- 对系统资源的要求（TCP较多，UDP少）；
- UDP程序结构较简单；
- 流模式与数据报模式 ；
- TCP保证数据正确性，UDP可能丢包；
- TCP保证数据顺序，UDP不保证。
```

9. HTTP协议中GET和POST的区别

```text
- post 请求的过程，会先将请求头发送给服务器进行确认，然后才真正发送数据；而 get 请求的过程，会在连接建立后会将请求头和请求数据一起发送。
- get 会将数据缓存起来，而 post 不会
- get 请求方式将请求信息放在 URL 后面，请求信息和 URL 之间以？隔开，请求信息的格式为键值对，例如 https://baike.baidu.com/item/Python/407313?fr=aladdin，这种请求方式将请求信息直接暴露在 URL 中，安全性较低。
- post 请求方式将请求信息放置在报文体中，相获得请求信息必须解析报文，因此安全性较 get 方式要高一些
- get 请求方式符合幂等性和安全性，post 不符合，post 请求方式往数据库中提交数据的，因此会改变数据库中的数据。
- 
```

10. 什么是幂等，如果是你如何设计来规避幂等造成的影响

```text
- 幂等性的定义：对数据库的一次操作和多次操作获得的结果是一致的，则认为符合幂等性。
- 安全性的定义：对数据库的操作没有改变数据库中的数据，则认为符合安全性。
- 全局唯一ID
- 去重表
    这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。
- 插入或更新
    这种方法插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。
- 多版本控制
    这种方法适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等
- 状态机控制
    这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的付款肯定是在之前，这时我们可以通过在设计状态字段时，使用int类型，并且通过值类型的大小来做幂等，比如订单的创建为0，付款成功为100。付款失败为99
```

11. 数据库如何保证事务，怎么解决数据库脏读问题，对应的隔离级别是什么

```text
事务是一个单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中,不会被其他客户端发送来的命令请求所打断。 
事务是一个原子操作:事务中的命令要么全部被执行,要么全部都不执行
数据库如何保证事务：回滚日志 / 
数据库事务四个特性(ACID)，原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。
- 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
- 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。
- 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
- Serializable 序列化
对应的隔离级别是什么：读未提交
```

12. hashcode()与equals()的关系

```text
先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。
```

13. 过滤器和拦截器的区别

```text
- 实现原理不同
    过滤器和拦截器 底层实现方式大不相同，过滤器 是基于函数回调的，拦截器 则是基于Java的反射机制（动态代理）实现的。
- 使用范围不同
    过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器 Filter 的使用要依赖于 Tomcat 等容器，导致它只能在web程序中使用。
    拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。  
- 触发时机不同
    过滤器 Filter 是在请求进入容器后，但在进入 servlet 之前进行预处理，请求结束是在 servlet 处理完以后。
    拦截器 Interceptor 是在请求进入 servlet 后，在进入 Controller 之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。
- 拦截的请求范围不同
    这是因为过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对 Controller 中请求或访问 static 目录下的资源请求起作用。
- 注入Bean情况不同
- 控制执行顺序不同
    过滤器用 @Order 注解控制执行顺序，通过 @Order 控制过滤器的级别，值越小级别越高越先执行。
    拦截器默认的执行顺序，就是它的注册顺序，也可以通过 Order 手动设置控制，值越小越先执行。
```

14. 怎么理解Spring AOP

```text
AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容（Spring核心之一），是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

- 切面(Aspect): 指关注点模块化,这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中,切面可以使用通用类基于模式的方式(schema-based approach)或者在普通类中以 @Aspect 注解(@AspectJ 注解方式)来实现。
- 连接点(Join point): 在程序执行过程中某个特定的点,例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中,一个连接点总是代表一个方法的执行。
- 通知(Advice): 在切面的某个特定的连接点上执行的动作。通知有多种类型,包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架,包括Spring在内,都是以拦截器做通知模型的,并维护着一个以连接点为中心的拦截器链。
- 切点(Pointcut): 匹配连接点的断言。通知和切点表达式相关联,并在满足这个切点的连接点上运行(例如,当执行某个特定名称的方法时)。切点表达式如何和连接点匹配是AOP的核心:Spring默认使用AspectJ 切点语义。
- 引入(Introduction): 声明额外的方法或者某个类型的字段。Spring允许引入新的接口(以及一个对应的实现)到任何被通知的对象上。例如,可以使用引入来使bean实现 IsModified 接口, 以便简化缓存机制(在AspectJ社区,引入也被称为内部类型声明(inter))。
- 目标对象(Target object): 被一个或者多个切面所通知的对象。也被称作被通知(advised)对象。既然Spring AOP是通过运行时代理实现的,那么这个对象永远是一个被代理(proxied)的对象。
- AOP代理(AOP proxy):AOP框架创建的对象,用来实现切面契约(aspect contract)(包括通知方法执行等功能)。在Spring中,AOP代理可以是JDK动态代理或CGLIB代理。
- 织入(Weaving): 把切面连接到其它的应用程序类型或者对象上,并创建一个被被通知的对象的过程。这个过程可以在编译时(例如使用AspectJ编译器)、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样,是在运行时完成织入的。 
```

15. 算法题（二分查找）

```java

```